<?php

namespace Defuse\Crypto;

use Defuse\Crypto\Exception as Ex;

class Crypto
{
    // Ciphertext format: [____VERSION____][____HMAC____][____SALT____][____IV____][____CIPHERTEXT____].
    // Legacy format: [____HMAC____][____IV____][____CIPHERTEXT____].

    /**
     * Encrypts a message.
     *
     * $plaintext is the message to encrypt.
     * $key is the encryption key, a value generated by createNewRandomKey().
     * You MUST catch exceptions thrown by this function. Read the docs.
     *
     * @param string $plaintext
     * @param string $key // TODO: this is wrong
     * @param bool   $raw_binary
     *
     * @throws Ex\CannotPerformOperationException
     *
     * @return string
     */
    public static function encrypt($plaintext, Key $key, $raw_binary = false)
    {
        return self::encryptInternal(
            $plaintext,
            KeyOrPassword::createFromKey($key),
            $raw_binary
        );
    }

    public static function encryptWithPassword($plaintext, $password, $raw_binary = false)
    {
        return self::encryptInternal(
            $plaintext,
            KeyOrPassword::createFromPassword($password),
            $raw_binary
        );
    }

    private static function encryptInternal($plaintext, KeyOrPassword $secret, $raw_binary)
    {
        RuntimeTests::runtimeTest();

        $salt = Core::secureRandom(Core::SALT_BYTE_SIZE);
        $keys = $secret->deriveKeys($salt);
        $ekey = $keys->getEncryptionKey();
        $akey = $keys->getAuthenticationKey();

        // Generate a random initialization vector.
        $ivsize = Core::cipherIvLength(Core::CIPHER_METHOD);
        $iv     = Core::secureRandom($ivsize);

        $ciphertext = Core::CURRENT_VERSION . $salt . $iv . self::plainEncrypt($plaintext, $ekey, $iv);
        $auth       = \hash_hmac(Core::HASH_FUNCTION_NAME, $ciphertext, $akey, true);

        $ciphertext = $ciphertext . $auth;

        if ($raw_binary) {
            return $ciphertext;
        }
        return Encoding::binToHex($ciphertext);
    }

    /**
     * Decrypts a ciphertext.
     * $ciphertext is the ciphertext to decrypt.
     * $key is the key that the ciphertext was encrypted with.
     * You MUST catch exceptions thrown by this function. Read the docs.
     *
     * @param string $ciphertext
     * @param string $key
     * @param bool   $raw_binary
     *
     * @throws Ex\CannotPerformOperationException
     * @throws Ex\WrongKeyOrModifiedCiphertextException
     *
     * @return string
     */
    public static function decrypt($ciphertext, Key $key, $raw_binary = false)
    {
        return self::decryptInternal(
            $ciphertext,
            KeyOrPassword::createFromKey($key),
            $raw_binary
        );
    }

    public static function decryptWithPassword($ciphertext, $password, $raw_binary = false)
    {
        return self::decryptInternal(
            $ciphertext,
            KeyOrPassword::createFromPassword($password),
            $raw_binary
        );
    }

    private static function decryptInternal($ciphertext, KeyOrPassword $secret, $raw_binary)
    {
        RuntimeTests::runtimeTest();

        if (! $raw_binary) {
            try {
                $ciphertext = Encoding::hexToBin($ciphertext);
            } catch (\RangeException $ex) {
                throw new Ex\WrongKeyOrModifiedCiphertextException(
                    'Ciphertext has invalid hex encoding.'
                );
            }
        }

        // Grab the header tag
        $header = Core::ourSubstr($ciphertext, 0, Core::HEADER_VERSION_SIZE);
        if ($header !== Core::CURRENT_VERSION) {
            throw new Ex\WrongKeyOrModifiedCiphertextException(
                'Bad version header.'
            );
        }

        // Now let's operate on the remainder of the ciphertext as normal
        $ciphertext = Core::ourSubstr($ciphertext, Core::HEADER_VERSION_SIZE, null);

        // Extract the HMAC from the front of the ciphertext.
        if (Core::ourStrlen($ciphertext) < Core::MAC_BYTE_SIZE) {
            throw new Ex\WrongKeyOrModifiedCiphertextException(
                'Ciphertext is too short.'
            );
        }
        $hmac = Core::ourSubstr(
            $ciphertext,
            Core::ourStrlen($ciphertext) - Core::MAC_BYTE_SIZE,
            Core::MAC_BYTE_SIZE
        );
        if ($hmac === false) {
            throw new Ex\CannotPerformOperationException();
        }
        $salt = Core::ourSubstr(
            $ciphertext,
            0,
            Core::SALT_BYTE_SIZE
        );
        if ($salt === false) {
            throw new Ex\CannotPerformOperationException();
        }

        $ciphertext = Core::ourSubstr(
            $ciphertext,
            Core::SALT_BYTE_SIZE,
            Core::ourStrlen($ciphertext) - Core::MAC_BYTE_SIZE - Core::SALT_BYTE_SIZE
        );
        if ($ciphertext === false) {
            throw new Ex\CannotPerformOperationException();
        }

        $keys = $secret->deriveKeys($salt);

        if (self::verifyHMAC($hmac, $header . $salt . $ciphertext, $keys->getAuthenticationKey())) {
            // Extract the initialization vector from the ciphertext.
            $ivsize = Core::cipherIvLength(Core::CIPHER_METHOD);
            if (Core::ourStrlen($ciphertext) < $ivsize) {
                throw new Ex\WrongKeyOrModifiedCiphertextException(
                    'Ciphertext is too short.'
                );
            }
            $iv = Core::ourSubstr($ciphertext, 0, $ivsize);
            if ($iv === false) {
                throw new Ex\CannotPerformOperationException();
            }
            $ciphertext = Core::ourSubstr($ciphertext, $ivsize);
            if ($ciphertext === false) {
                throw new Ex\CannotPerformOperationException();
            }

            $plaintext = self::plainDecrypt($ciphertext, $keys->getEncryptionKey(), $iv, Core::CIPHER_METHOD);

            return $plaintext;
        } else {
            /*
             * We throw an exception instead of returning false because we want
             * a script that doesn't handle this condition to CRASH, instead
             * of thinking the ciphertext decrypted to the value false.
             */
            throw new Ex\WrongKeyOrModifiedCiphertextException(
                'Integrity check failed.'
            );
        }
    }

    /**
     * Decrypts a ciphertext (legacy -- before version tagging)
     *
     * $ciphertext is the ciphertext to decrypt.
     * $key is the key that the ciphertext was encrypted with.
     * You MUST catch exceptions thrown by this function. Read the docs.
     *
     * @param string $ciphertext
     * @param string $key
     *
     * @throws Ex\CannotPerformOperationException
     * @throws Ex\WrongKeyOrModifiedCiphertextException
     *
     * @return string
     */
    public static function legacyDecrypt($ciphertext, $key)
    {
        RuntimeTests::runtimeTest();

        // Extract the HMAC from the front of the ciphertext.
        if (Core::ourStrlen($ciphertext) <= Core::LEGACY_MAC_BYTE_SIZE) {
            throw new Ex\WrongKeyOrModifiedCiphertextException(
                'Ciphertext is too short.'
            );
        }
        $hmac = Core::ourSubstr($ciphertext, 0, Core::LEGACY_MAC_BYTE_SIZE);
        if ($hmac === false) {
            throw new Ex\CannotPerformOperationException();
        }
        $ciphertext = Core::ourSubstr($ciphertext, Core::LEGACY_MAC_BYTE_SIZE);
        if ($ciphertext === false) {
            throw new Ex\CannotPerformOperationException();
        }

        // Regenerate the same authentication sub-key.
        $akey = Core::HKDF(
            Core::LEGACY_HASH_FUNCTION_NAME,
            $key,
            Core::LEGACY_KEY_BYTE_SIZE,
            Core::LEGACY_AUTHENTICATION_INFO_STRING,
            null
        );

        if (self::verifyHMAC($hmac, $ciphertext, $akey)) {
            // Regenerate the same encryption sub-key.
            $ekey = Core::HKDF(
                Core::LEGACY_HASH_FUNCTION_NAME,
                $key,
                Core::LEGACY_KEY_BYTE_SIZE,
                Core::LEGACY_ENCRYPTION_INFO_STRING,
                null
            );

            // Extract the initialization vector from the ciphertext.
            $ivsize = Core::cipherIvLength(Core::LEGACY_CIPHER_METHOD);
            if (Core::ourStrlen($ciphertext) <= $ivsize) {
                throw new Ex\WrongKeyOrModifiedCiphertextException(
                    'Ciphertext is too short.'
                );
            }
            $iv = Core::ourSubstr($ciphertext, 0, $ivsize);
            if ($iv === false) {
                throw new Ex\CannotPerformOperationException();
            }
            $ciphertext = Core::ourSubstr($ciphertext, $ivsize);
            if ($ciphertext === false) {
                throw new Ex\CannotPerformOperationException();
            }

            $plaintext = self::plainDecrypt($ciphertext, $ekey, $iv, Core::LEGACY_CIPHER_METHOD);

            return $plaintext;
        } else {
            /*
             * We throw an exception instead of returning false because we want
             * a script that doesn't handle this condition to CRASH, instead
             * of thinking the ciphertext decrypted to the value false.
             */
            throw new Ex\WrongKeyOrModifiedCiphertextException(
                'Integrity check failed.'
            );
        }
    }

    /**
     * You MUST NOT call this method directly.
     *
     * Unauthenticated message encryption.
     *
     * @param string $plaintext
     * @param string $key
     * @param string $iv
     *
     * @throws Ex\CannotPerformOperationException
     *
     * @return string
     */
    protected static function plainEncrypt($plaintext, $key, $iv)
    {
        Core::ensureConstantExists('OPENSSL_RAW_DATA');
        Core::ensureFunctionExists('openssl_encrypt');
        $ciphertext = \openssl_encrypt(
            $plaintext,
            Core::CIPHER_METHOD,
            $key,
            OPENSSL_RAW_DATA,
            $iv
        );

        if ($ciphertext === false) {
            throw new Ex\CannotPerformOperationException(
                'openssl_encrypt() failed.'
            );
        }

        return $ciphertext;
    }

    /**
     * You MUST NOT call this method directly.
     *
     * Unauthenticated message deryption.
     *
     * @param string $ciphertext
     * @param string $key
     * @param string $iv
     * @param string $cipherMethod
     *
     * @throws Ex\CannotPerformOperationException
     *
     * @return string
     */
    protected static function plainDecrypt($ciphertext, $key, $iv, $cipherMethod)
    {
        Core::ensureConstantExists('OPENSSL_RAW_DATA');
        Core::ensureFunctionExists('openssl_decrypt');
        $plaintext = \openssl_decrypt(
            $ciphertext,
            $cipherMethod,
            $key,
            OPENSSL_RAW_DATA,
            $iv
        );
        if ($plaintext === false) {
            throw new Ex\CannotPerformOperationException(
                'openssl_decrypt() failed.'
            );
        }

        return $plaintext;
    }

    /**
     * Verify an HMAC without timing/cache side-channel leakage.
     *
     * @param string $correct_hmac HMAC string (raw binary)
     * @param string $message      Ciphertext (raw binary)
     * @param string $key          Authentication key (raw binary)
     *
     * @throws Ex\CannotPerformOperationException
     *
     * @return bool
     */
    protected static function verifyHMAC($correct_hmac, $message, $key)
    {
        $message_hmac = \hash_hmac(Core::HASH_FUNCTION_NAME, $message, $key, true);
        return Core::hashEquals($correct_hmac, $message_hmac);
    }
}
